# -*- coding: utf-8 -*-
"""crime_live_update.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15IcQuF6W-sCNGjh9WzjgGfPNIfGU2bvj
"""

import pandas as pd
import re
import os


def update_precinct_crime_data(
    crime_data_dict, file_path, crimes_of_interest, precinct_pattern="cs-en-us-(\d+pct)"
):
    """
    Updates the provided crime data dictionary with 'Week to Date' crime data for the year 2024 from the given Excel file.

    Parameters:
    - crime_data_dict: dict, the existing dictionary of crime data to update
    - file_path: str, path to the Excel file
    - crimes_of_interest: list, crime categories to filter by
    - precinct_pattern: str, regex pattern to extract precinct information from the filename

    Returns:
    - None; the function updates the dictionary in place
    """
    # Extract precinct number from the file name using regex
    precinct_match = re.search(precinct_pattern, file_path)
    if precinct_match:
        precinct = precinct_match.group(1)
    else:
        # This will match non-numerical precincts such as 'pbms' and 'pbmn'
        additional_precinct_match = re.search(r"cs-en-us-(pbms|pbmn)\.xlsx", file_path)
        if additional_precinct_match:
            precinct = additional_precinct_match.group(1)
        else:
            precinct = "unknown_precinct"

    # Load the Excel file, skip headers and footers, and assume data starts after 'Crime Type' column
    data = pd.read_excel(
        file_path,
        sheet_name="CompStat_1",
        skiprows=10,
        usecols="A,C",
        names=["Crime Type", "Week to Date 2024"],
    )

    # Drop rows with NaN values as these don't contain crime data
    data_cleaned = data.dropna()

    # Filter out the rows to include only the crime types specified
    data_filtered = data_cleaned[data_cleaned["Crime Type"].isin(crimes_of_interest)]

    # Drop any potential duplicate rows, keeping the first instance (relevant for 'TOTAL')
    data_filtered = data_filtered.drop_duplicates(subset=["Crime Type"], keep="first")

    # Update the dictionary with the new data
    crime_data_dict[precinct] = data_filtered.set_index("Crime Type").to_dict()[
        "Week to Date 2024"
    ]


def auto_update_crime_data(base_path, crimes_of_interest, start=1, end=34):
    """
    Automatically updates the crime data dictionary for all precinct files within a range.

    Parameters:
    - base_path: str, the base directory where the Excel files are stored
    - crimes_of_interest: list, crime categories to filter by
    - start: int, the starting precinct number
    - end: int, the ending precinct number

    Returns:
    - crime_data_dict: dict, containing all updated crime data
    """
    crime_data_dict = {}

    for i in range(start, end + 1):
        # Construct the file name with leading zeros
        file_name = f"cs-en-us-{str(i).zfill(3)}pct.xlsx"
        file_path = os.path.join(base_path, file_name)
        # print(file_name)

        # Check if the file exists before trying to process it
        if os.path.exists(file_path):
            # print(file_path)
            update_precinct_crime_data(crime_data_dict, file_path, crimes_of_interest)

    return crime_data_dict


def calculate_safety_scores():
    """
    Calculates safety scores for each precinct based on crime data, crime classifications, and crime weights.

    Args:
        precinct_crimes (dict): Dictionary with each precinct's crime data.
        crime_class_mapping (dict): Maps crime types to their classes.
        crime_weights (dict): Weights assigned to each crime class.

    Returns:
        dict: Dictionary with each precinct and its calculated safety score.
    """
    precinct_scores = {}

    crime_class_mapping = {
        "Murder": "Class A Felony",
        "Rape": "Class B Felony",
        "Robbery": "Class D Felony",
        "Fel. Assault": "Class B Felony",
        "Burglary": "Class B Violet Felony",
        "Gr. Larceny": "Class B Felony",
        "G.L.A": "Class B Felony",
    }

    crime_weights = {
        "Class A Felony": 10,
        "Class B Violent Felony": 9,
        "Class B Felony": 8,
        "Class C Felony": 7,
        "Class D Felony": 6,
        "Class E Felony": 5,
        "Class A Misdemeanor": 3,
        "Class B Misdemeanor": 2,
        "Class C Misdemeanor": 1,
        "Unspecified": 0.5,  # Assigning a nominal weight for unspecified categories
    }
    base_path = "backend/utils/data/crime_data"

    # Define the crimes we're interested in
    crimes_of_interest = [
        "Murder",
        "Rape",
        "Robbery",
        "Fel. Assault",
        "Burglary",
        "Gr. Larceny",
        "G.L.A.",
        "TOTAL",
    ]

    # Automatically update the crime data dictionary with all precinct data from 001 to 034
    precinct_crimes = auto_update_crime_data(base_path, crimes_of_interest)

    for precinct, crimes in precinct_crimes.items():
        safety_score = 0
        for crime, count in crimes.items():
            if crime == "TOTAL":  # Skip the total count if present in the data
                continue
            crime_class = crime_class_mapping.get(
                crime, "Unspecified"
            )  # Get the crime class or 'Unspecified'
            weight = crime_weights.get(
                crime_class, 0.5
            )  # Get the weight for the crime class or 0.5 if not found
            safety_score += int(count) * weight  # Calculate the score and accumulate

        precinct_scores[precinct] = safety_score
    new_keys_precinct_scores = {int(k[:-3]): v for k, v in precinct_scores.items()}
    return new_keys_precinct_scores
